import{_ as e,c as o,o as a,a3 as r}from"./chunks/framework.z7kdJ_yr.js";const p=JSON.parse('{"title":"前端安全","description":"","frontmatter":{},"headers":[],"relativePath":"Deepunderstanding/P1 深入理解系列/9.前端安全.md","filePath":"Deepunderstanding/P1 深入理解系列/9.前端安全.md"}'),i={name:"Deepunderstanding/P1 深入理解系列/9.前端安全.md"},t=r('<h1 id="前端安全" tabindex="-1">前端安全 <a class="header-anchor" href="#前端安全" aria-label="Permalink to &quot;前端安全&quot;">​</a></h1><h2 id="xss" tabindex="-1">XSS <a class="header-anchor" href="#xss" aria-label="Permalink to &quot;XSS&quot;">​</a></h2><h3 id="什么是-xss" tabindex="-1">什么是 XSS <a class="header-anchor" href="#什么是-xss" aria-label="Permalink to &quot;什么是 XSS&quot;">​</a></h3><ul><li>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全</li></ul><h3 id="xss-分类" tabindex="-1">XSS 分类 <a class="header-anchor" href="#xss-分类" aria-label="Permalink to &quot;XSS 分类&quot;">​</a></h3><ul><li><p>存储型 XSS</p><blockquote><p>攻击者将恶意代码提交到目标网站的数据库中。 <br>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 <br>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 <br>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p></blockquote></li><li><p>反射型 XSS</p><blockquote><p>攻击者构造出特殊的 URL，其中包含恶意代码。 <br>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 <br>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 <br>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p></blockquote></li><li><p>DOM 型 XSS</p><blockquote><p>攻击者构造出特殊的 URL，其中包含恶意代码。 <br>用户打开带有恶意代码的 URL。 <br>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 <br>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p></blockquote></li></ul><h2 id="xss-防范措施" tabindex="-1">XSS 防范措施 <a class="header-anchor" href="#xss-防范措施" aria-label="Permalink to &quot;XSS 防范措施&quot;">​</a></h2><ul><li><p>Content Security Policy</p><blockquote><p>禁止加载外域代码，防止复杂的攻击逻辑 <br>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域 <br>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用） <br>禁止未授权的脚本执行（新特性，Google Map 移动版在使用） <br>合理使用上报可以及时发现 XSS，利于尽快修复问题</p></blockquote></li><li><p>输入内容长度控制</p><blockquote><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度</p></blockquote></li><li><p>其他安全措施</p><blockquote><p>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 <br>验证码：防止脚本冒充用户提交危险操作。</p></blockquote></li></ul><h2 id="csrf-攻击" tabindex="-1">CSRF 攻击 <a class="header-anchor" href="#csrf-攻击" aria-label="Permalink to &quot;CSRF 攻击&quot;">​</a></h2><h3 id="什么是-csrf" tabindex="-1">什么是 CSRF <a class="header-anchor" href="#什么是-csrf" aria-label="Permalink to &quot;什么是 CSRF&quot;">​</a></h3><ul><li>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的</li></ul><h3 id="典型过程" tabindex="-1">典型过程 <a class="header-anchor" href="#典型过程" aria-label="Permalink to &quot;典型过程&quot;">​</a></h3><blockquote><p>受害者登录 a.com，并保留了登录凭证（Cookie） <br> 攻击者引诱受害者访问了 b.com <br> b.com 向 a.com 发送了一个请求：a.com/act=xx 浏览器会默认携带 a.com 的 Cookie <br> a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求 <br> a.com 以受害者的名义执行了 act=xx <br> 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作</p></blockquote><h3 id="csrf-的特点" tabindex="-1">CSRF 的特点 <a class="header-anchor" href="#csrf-的特点" aria-label="Permalink to &quot;CSRF 的特点&quot;">​</a></h3><blockquote><p>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生 <br>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据 <br>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用” <br>跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪</p></blockquote><h2 id="csrf-防护策略" tabindex="-1">CSRF 防护策略 <a class="header-anchor" href="#csrf-防护策略" aria-label="Permalink to &quot;CSRF 防护策略&quot;">​</a></h2><ul><li><p>根据 CSRF 的两个特点：</p><blockquote><p>CSRF（通常）发生在第三方域名。 <br>CSRF 攻击者不能获取到 Cookie 等信息，只是使用。</p></blockquote></li><li><p>针对这两点，我们可以专门制定防护策略，如下：</p></li><li><blockquote><p>阻止不明外域的访问 <br>同源检测 <br>Samesite Cookie</p></blockquote></li><li><blockquote><p>提交时要求附加本域才能获取的信息 <br>CSRF Token <br>双重 Cookie 验证</p></blockquote></li></ul><h2 id="csrf-防护-同源检测" tabindex="-1">CSRF 防护-同源检测 <a class="header-anchor" href="#csrf-防护-同源检测" aria-label="Permalink to &quot;CSRF 防护-同源检测&quot;">​</a></h2><ul><li>使用 Origin Header 确定来源域名</li><li>使用 Referer Header 确定来源域名 <blockquote><p>设置 Referrer Policy 的方法有三种： <br>在 CSP 设置 <br>页面头部增加 meta 标签 <br>a 标签增加 referrerpolicy 属性</p></blockquote></li></ul><h2 id="csrf-防护-token" tabindex="-1">CSRF 防护-Token <a class="header-anchor" href="#csrf-防护-token" aria-label="Permalink to &quot;CSRF 防护-Token&quot;">​</a></h2><ul><li>CSRF Token 的防护策略分为三个步骤</li></ul><ol><li>将 CSRF Token 输出到页面中</li><li>页面提交的请求携带这个 Token</li><li>服务器验证 Token 是否正确</li></ol><h2 id="csrf-防护-双重-cookie-验证" tabindex="-1">CSRF 防护-双重 Cookie 验证 <a class="header-anchor" href="#csrf-防护-双重-cookie-验证" aria-label="Permalink to &quot;CSRF 防护-双重 Cookie 验证&quot;">​</a></h2><ul><li>双重 Cookie 采用以下流程：</li></ul><ol><li>在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串（例如 csrfcookie=v8g9e4ksfhw）。</li><li>在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例 POST <a href="https://www.a.com/comment?csrfcookie=v8g9e4ksfhw%EF%BC%89%E3%80%82" target="_blank" rel="noreferrer">https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。</a></li><li>后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。</li></ol><h2 id="csrf-防护-samesite-cookie-属性" tabindex="-1">CSRF 防护-Samesite Cookie 属性 <a class="header-anchor" href="#csrf-防护-samesite-cookie-属性" aria-label="Permalink to &quot;CSRF 防护-Samesite Cookie 属性&quot;">​</a></h2><blockquote><p>从源头上解决这个问题，Google 起草了一份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax</p></blockquote><ul><li><p>Samesite=Strict</p><blockquote><p>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外</p></blockquote></li><li><p>Samesite=Lax</p><blockquote><p>这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 Cookie 可以作为第三方 Cookie</p></blockquote></li></ul><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noreferrer">https://tech.meituan.com/2018/09/27/fe-security.html</a></li><li><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noreferrer">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a></li><li><a href="https://web.dev/articles/samesite-cookies-explained?hl=zh-cn" target="_blank" rel="noreferrer">https://web.dev/articles/samesite-cookies-explained?hl=zh-cn</a></li></ul>',30),l=[t];function c(s,h,n,b,k,u){return a(),o("div",null,l)}const d=e(i,[["render",c]]);export{p as __pageData,d as default};
