import{_ as t,c as d,o as e,a3 as a}from"./chunks/framework.b23AWjfV.js";const g=JSON.parse('{"title":"webpack loader vs plugin","description":"","frontmatter":{},"headers":[],"relativePath":"MiscellaneousTalk/P1 概念系列/3.webpack loader vs plugin.md","filePath":"MiscellaneousTalk/P1 概念系列/3.webpack loader vs plugin.md"}'),r={name:"MiscellaneousTalk/P1 概念系列/3.webpack loader vs plugin.md"},l=a('<h1 id="webpack-loader-vs-plugin" tabindex="-1">webpack loader vs plugin <a class="header-anchor" href="#webpack-loader-vs-plugin" aria-label="Permalink to &quot;webpack loader vs plugin&quot;">​</a></h1><h2 id="loader-和-plugin-差异" tabindex="-1">loader 和 plugin 差异 <a class="header-anchor" href="#loader-和-plugin-差异" aria-label="Permalink to &quot;loader 和 plugin 差异&quot;">​</a></h2><ul><li><p>在 webpack 中，loader 和 plugin 是两个不同的概念，它们分别用于不同的任务。</p></li><li><p>Loader 用于对模块的源代码进行转换，将非 JavaScript 文件（如 TypeScript、ES6+、Sass、Less 等）转换为 webpack 可以处理的有效模块，并且可以链式调用多个 loader 对文件进行处理。例如，babel-loader 用于将 ES6+ 代码转换为向后兼容的 JavaScript，css-loader 用于解析处理 CSS 文件等。</p></li><li><p>Plugin 用于执行更广泛的任务，它可以用于执行各种任务，包括打包优化、资源管理、注入环境变量等。插件可以监听 webpack 构建生命周期的事件，并在适当的时机执行自定义的任务。例如，html-webpack-plugin 用于根据模板自动生成 HTML 代码，clean-webpack-plugin 用于清理每次打包下没有使用的文件，uglifyjs-webpack-plugin 用于压缩混淆 JS 代码等。</p></li><li><p>因此，可以简单地理解为 loader 用于处理模块的源代码转换，而 plugin 用于执行更广泛的构建任务和优化。在 webpack 的配置中，loader 通常用于 module.rules，而 plugin 通过 plugins 属性进行配置。</p></li></ul><h2 id="常用-loader" tabindex="-1">常用 loader <a class="header-anchor" href="#常用-loader" aria-label="Permalink to &quot;常用 loader&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Loader</th><th>功能</th></tr></thead><tbody><tr><td>style-loader</td><td>将 CSS 代码注入到 DOM 中的 style 标签中</td></tr><tr><td>css-loader</td><td>解析 CSS 文件，处理 @import 和 url() 等语句</td></tr><tr><td>less-loader</td><td>将 Less 文件编译为 CSS</td></tr><tr><td>sass-loader</td><td>将 Sass/SCSS 文件编译为 CSS</td></tr><tr><td>raw-loader</td><td>将文件以字符串的形式导入</td></tr><tr><td>file-loader</td><td>处理文件，将文件复制到输出目录，并返回相对 URL</td></tr><tr><td>url-loader</td><td>类似 file-loader，但可以将小文件转换为 base64 URL</td></tr><tr><td>csv-loader</td><td>解析 CSV 文件</td></tr><tr><td>xml-loader</td><td>解析 XML 文件</td></tr><tr><td>mocha-loader</td><td>在 Mocha 测试框架中运行测试</td></tr><tr><td>jshint-loader</td><td>使用 JSHint 进行 JavaScript 代码的静态分析</td></tr><tr><td>eslint-loader</td><td>使用 ESLint 进行 JavaScript 代码的静态分析</td></tr><tr><td>babel-loader</td><td>将 ES6+ 代码转换为向后兼容的 JavaScript</td></tr><tr><td>coffee-loader</td><td>将 CoffeeScript 代码编译为 JavaScript</td></tr><tr><td>ts-loader</td><td>将 TypeScript 代码编译为 JavaScript</td></tr></tbody></table><h2 id="常用-plugin" tabindex="-1">常用 plugin <a class="header-anchor" href="#常用-plugin" aria-label="Permalink to &quot;常用 plugin&quot;">​</a></h2><table tabindex="0"><thead><tr><th>插件名称</th><th>功能</th></tr></thead><tbody><tr><td>html-webpack-plugin</td><td>根据模板自动生成 HTML 代码，并自动引用 CSS 和 JS 文件</td></tr><tr><td>extract-text-webpack-plugin</td><td>将 JS 文件中引用的样式单独抽离成 CSS 文件</td></tr><tr><td>optimize-css-assets-webpack-plugin</td><td>快速去重不同组件中重复的 CSS</td></tr><tr><td>webpack-bundle-analyzer</td><td>webpack 的 bundle 文件分析工具，以可交互缩放的 treemap 形式展示 bundle 文件</td></tr><tr><td>compression-webpack-plugin</td><td>生产环境可采用 gzip 压缩 JS 和 CSS</td></tr><tr><td>happypack</td><td>通过多进程模型来加速代码构建</td></tr><tr><td>clean-webpack-plugin</td><td>清理每次打包下没有使用的文件</td></tr><tr><td>MiniCssExtractPlugin</td><td>将 CSS 提取为独立的文件，支持按需加载 CSS 和 source map</td></tr><tr><td>CopyWebpackPlugin</td><td>复制文件和文件夹，用于构建结束后复制一些静态资源到输出目录</td></tr><tr><td>ImageminWebpackPlugin</td><td>用于压缩图片文件</td></tr><tr><td>ProvidePlugin</td><td>在每个模块中注入变量，使其在所有模块中可用，无需显式引入</td></tr><tr><td>BundleAnalyzerPlugin</td><td>分析 bundle 内容，帮助优化构建输出</td></tr><tr><td>DefinePlugin</td><td>允许在编译时创建全局常量，可以在开发和生产构建中使用不同的值</td></tr><tr><td>HotModuleReplacementPlugin</td><td>在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面</td></tr><tr><td>FriendlyErrorsWebpackPlugin</td><td>友好地输出 webpack 构建信息和错误日志</td></tr><tr><td>DllPlugin 和 DllReferencePlugin</td><td>用于分离第三方库，提高构建速度</td></tr></tbody></table>',7),i=[l];function o(p,n,c,s,u,b){return e(),d("div",null,i)}const h=t(r,[["render",o]]);export{g as __pageData,h as default};
