import{_ as e,c as t,o,a3 as l}from"./chunks/framework.z7kdJ_yr.js";const h=JSON.parse('{"title":"前端工程化","description":"","frontmatter":{},"headers":[],"relativePath":"MiscellaneousTalk/P1 概念系列/13.前端工程化.md","filePath":"MiscellaneousTalk/P1 概念系列/13.前端工程化.md"}'),a={name:"MiscellaneousTalk/P1 概念系列/13.前端工程化.md"},c=l('<h1 id="前端工程化" tabindex="-1">前端工程化 <a class="header-anchor" href="#前端工程化" aria-label="Permalink to &quot;前端工程化&quot;">​</a></h1><h2 id="什么是前端工程化" tabindex="-1">什么是前端工程化？ <a class="header-anchor" href="#什么是前端工程化" aria-label="Permalink to &quot;什么是前端工程化？&quot;">​</a></h2><ul><li><p>前端工程化是针对现代 Web 开发复杂性不断提高而提出的一种开发理念与实践方法。它将软件工程的原理、技术和工具应用于前端开发过程中，旨在通过<code>规范化</code>、<code>模块化</code>、<code>自动化</code>和<code>组件化</code>等手段<code>提升开发效率</code>、<code>保证代码质量</code>，并<code>降低维护成本</code>。</p></li><li><p>总之就是，不停地改良前端项目的开发流程，让开发者能够更高效地开发、更好地进行团队协作、让代码的风格标准化、对资源做压缩以及懒加载、更好地交付部署</p></li></ul><blockquote><p>一开始，网页页面并不复杂，只是提供一些简单的展示和交互的静态页面，甚至不需要后端。</p></blockquote><blockquote><p>后来需要根据不同用户返回不同的页面信息，此时我们会用后端读取数据，配合一些模板引擎，在后端拼接好内容再返回，这就是所谓的服务端渲染（SSR）。</p></blockquote><blockquote><p>再后来，页面变得非常复杂，于是出现了前后端分离，前端被单独拎了出来，专门写 html、css 和 js，变成了 单页面应用（SPA）。但复杂也带来了很多问题，比如多个脚本的执行时机不对、css 名冲突、文件过于臃肿、错误的缓存导致没能下载最新的资源，等前端复杂后出现的一系列问题。</p></blockquote><blockquote><p>随着 Nodejs 的诞生，我们可以用 JS 去写前端工具了。为了解决上面这些问题，前端界出现了一大堆的工具和框架：Gulp、Angular、babel、Sass、React、Vue、Webpack、Yarn、TypeScript、ESLint、Docker、k8s 等等</p></blockquote><h2 id="前端工程化-模块化" tabindex="-1">前端工程化-模块化 <a class="header-anchor" href="#前端工程化-模块化" aria-label="Permalink to &quot;前端工程化-模块化&quot;">​</a></h2><ul><li><p>JS 的模块化</p><blockquote><p>将代码做了拆分，解决全局变量污染、依赖关系不清晰、多人协作不方便、脚本引入顺序、单元测试等问题</p></blockquote><blockquote><p>采用 CommonJS、AMD、UMD 或 ES6 的 import/export 机制实现代码模块化，增强复用性和可维护性</p></blockquote></li><li><p>CSS 的模块化</p><blockquote><p>通过 CSS Modules、CSS-in-JS、Vue 特有的 CSS Scoped 等方案，将 CSS 模块化，避免样式表中的全局命名冲突问题</p></blockquote><blockquote><p>借助 CSS Modules 或其他预处理器（Sass, Less）避免样式表中的全局命名冲突问题</p></blockquote></li><li><p>HTML 的模块化</p><blockquote><p>html 通常是动态的，在服务端我们会使用模板引擎（template），将得到的数据注入到占位符中。在后端 Nodejs，我们可以用 pug（曾用名 Jade）、handlebars、ejs 等。</p></blockquote><blockquote><p>前后端分离后，我们通常使用的是 Vue 的 template（类似 handlebars 语法）以及 React 的 JSX。</p></blockquote><blockquote><p>Web Components 是 W3C 标准，允许开发者创建可重用的、自包含的 UI 组件。通过<code>&lt;template&gt;</code>标签定义组件结构，使用 customElements.define()注册定制元素，并利用 Shadow DOM 实现样式和内容的封装隔离</p></blockquote></li><li><p>资源整合模块化</p><blockquote><p>解决不同类型的资源无法组织在一起问题，比如 JS 引擎能识别引入的 js 文件，但无法识别 css 文件</p></blockquote><blockquote><p>使用 Webpack、Rollup 等构建工具，可以将 CSS、JavaScript 以及图片等资源进行模块化处理，并且合并、压缩、按需加载等优化</p></blockquote><blockquote><p>比如图片，它可以先变成一个静态资源服务的一个资源，然后在 js 文件 import 的时候在转换为一个 url 字符串，或者直接就变成一个 base64 字符串</p></blockquote></li></ul><h2 id="前端工程化-组件化" tabindex="-1">前端工程化-组件化 <a class="header-anchor" href="#前端工程化-组件化" aria-label="Permalink to &quot;前端工程化-组件化&quot;">​</a></h2><ul><li><p>解决<code>原本的以资源类型为单位进行组织的管理</code>（所有 JS 文件放一个文件夹、CSS 同理），<code>维护困难</code>，<code>不好复用</code>的问题</p><blockquote><p>组件化是 <code>UI 层面上的更细粒度的拆分</code>，一种类似 div 等原生元素的 “自定义元素”。</p></blockquote><blockquote><p><code>组件有自己的 HTML、CSS 和 JS</code>，同时有自己的状态，并支持嵌入到其他组件中并接受外部的数据，可以进行复用。组件化可以看作是 UI 层组织方式的一种模块化。</p></blockquote><blockquote><p>目前主流的 React、Vue 或 Angular 等框架构建可复用、易维护的 UI 组件，遵循 DRY 原则，降低代码重复度。</p></blockquote></li></ul><h2 id="前端工程化-规范化" tabindex="-1">前端工程化-规范化 <a class="header-anchor" href="#前端工程化-规范化" aria-label="Permalink to &quot;前端工程化-规范化&quot;">​</a></h2><ul><li><code>编码规范</code>：通过工具如 ESLint 统一团队的编程风格和格式。</li><li><code>构建流程标准化</code>：利用 Webpack 或 Rollup 等构建工具设定清晰的编译、压缩、打包、部署等流程。</li><li><code>项目结构合理化</code>：建立合理的目录结构，便于组织和管理不同功能模块的源码</li><li><code>git 工作流</code>: git hook、commitlint 工具等</li><li>其他： <blockquote><p>目录结构规定。<br> 代码风格（包括 JS、HTML、CSS）。<br> 注释规范。<br> Code Review。<br> 请求接口规范。</p></blockquote></li></ul><h2 id="前端工程化-自动化" tabindex="-1">前端工程化-自动化 <a class="header-anchor" href="#前端工程化-自动化" aria-label="Permalink to &quot;前端工程化-自动化&quot;">​</a></h2><ul><li><p><code>重复的可以自动化的流程化工作</code>，应该尽量去自动化。让人去做，对人是一种折磨，然后也不能保证质量，因为通常流程也很复杂，即使是简单，做多了也容易错</p><blockquote><p>自动化构建：配置持续集成/持续部署(CI/CD)流程，确保每次代码提交后自动执行构建、测试和部署任务。工具有 Jenkins、GitLab CI/CD、GitHub Action、Docker（发布制品） 和 k8s（容器编排）等</p></blockquote><blockquote><p>自动化测试：编写单元测试、集成测试以及端到端测试脚本，保证代码质量和应用稳定性。</p></blockquote><blockquote><p>脚手架工具：通过 Yeoman、Create React App 等工具快速生成项目模板，简化初始化过程并提供最佳实践。</p></blockquote></li></ul><h2 id="前端工程化-其他" tabindex="-1">前端工程化-其他 <a class="header-anchor" href="#前端工程化-其他" aria-label="Permalink to &quot;前端工程化-其他&quot;">​</a></h2><table tabindex="0"><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>Babel</td><td>开发时使用高版本 ES 语言特性，通过 Babel 转换为低版本（如 ES5）兼容代码。打包工具内部集成使用 Babel 进行编译转换。</td></tr><tr><td>tsc</td><td>TypeScript 编译器，不仅支持将 TS 编译成 JS，还能够编译为指定的 JS 版本，以实现跨环境兼容性。</td></tr><tr><td>Polyfill</td><td>对于低版本浏览器不支持的新 API，提供模拟实现的库，例如 core-js，使旧版浏览器也能使用部分新特性。但有些语言层面上的新特性无法 polyfill。</td></tr><tr><td>Monorepo</td><td>将多个项目放在一个 Git 仓库中管理，方便共享和维护公共依赖，采用 Lerna、Yarn Workspaces 等工具进行统一构建发布。</td></tr><tr><td>异常监控</td><td>当前端发生错误时，通过 Sentry 等服务收集并上报异常信息，结合 SourceMap 可精准定位到源码中的错误位置。</td></tr><tr><td>制品库</td><td>使用 Nexus 部署私有制品库，用于存储和分发不同类型的制品资源，包括 Docker 镜像、npm 包等，并与 CI/CD 流程配合。</td></tr><tr><td>VSCode Snippet</td><td>在 VSCode 中自定义代码片段，简化常用或复杂模板代码的编写，提高开发效率，属于自动化开发的一部分。</td></tr><tr><td>Mock</td><td>在后端接口未完成时，通过 YAPI 等平台创建虚假数据模拟接口返回，便于前端独立调试和开发。</td></tr><tr><td>单元测试</td><td>以模块为单位进行逻辑验证测试，确保代码功能正确无误。Jest 是一种流行的单元测试库，在提交或合并代码前执行测试用例。</td></tr><tr><td>热重载</td><td>在开发过程中实时监测代码变更，并自动重新编译受影响的模块，无需刷新整个页面即可查看更新结果，提升开发体验。</td></tr><tr><td>组件库文档</td><td>使用 Storybook 创建组件库的交互式文档展示，Vue 组件也可选用 Vue Press 构建文档系统，便于组件的管理和复用。</td></tr><tr><td>Tree shaking</td><td>在打包阶段移除那些虽然被导入但实际并未使用的模块，优化输出文件大小，Webpack 和 Rollup 等打包工具支持此特性。</td></tr></tbody></table><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://www.51cto.com/article/741101.html" target="_blank" rel="noreferrer">https://www.51cto.com/article/741101.html</a></li></ul>',19),d=[c];function r(i,p,u,b,s,n){return o(),t("div",null,d)}const q=e(a,[["render",r]]);export{h as __pageData,q as default};
