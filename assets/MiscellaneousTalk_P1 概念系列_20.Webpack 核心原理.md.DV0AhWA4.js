import{_ as t,c as d,o as e,a3 as o}from"./chunks/framework.b23AWjfV.js";const k=JSON.parse('{"title":"Webpack 核心原理","description":"","frontmatter":{},"headers":[],"relativePath":"MiscellaneousTalk/P1 概念系列/20.Webpack 核心原理.md","filePath":"MiscellaneousTalk/P1 概念系列/20.Webpack 核心原理.md"}'),c={name:"MiscellaneousTalk/P1 概念系列/20.Webpack 核心原理.md"},r=o('<h1 id="webpack-核心原理" tabindex="-1">Webpack 核心原理 <a class="header-anchor" href="#webpack-核心原理" aria-label="Permalink to &quot;Webpack 核心原理&quot;">​</a></h1><p>Webpack 最核心的功能: 将各种类型的资源，包括图片、css、js 等，转译、组合、拼接、生成 JS 格式的 bundler 文件</p><p><code>webpack 三大的体系知识：</code></p><ul><li>构建的核心流程</li><li>loader 的作用</li><li>plugin 架构与常用套路</li></ul><p><code>webpack 两大核心对象</code></p><ul><li><p><code>Compiler</code>：webpack 从开始执行到结束，Compiler 只会实例化一次。<code>compiler 对象记录了 webpack 运行环境的所有的信息</code>，插件可以通过它获取到 webpack 的配置信息，如 entry、output、module 等配置</p></li><li><p><code>Compilation</code>：提供了 webpack 大部分生命周期 Hook API 供自定义处理时做拓展使用。一个 <code>compilation 对象记录了一次构建到生成资源过程中的信息</code>，它储存了当前的模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息</p></li></ul><h2 id="构建的核心流程" tabindex="-1">构建的核心流程 <a class="header-anchor" href="#构建的核心流程" aria-label="Permalink to &quot;构建的核心流程&quot;">​</a></h2><p>这个过程核心完成了 内容转换 + 资源合并 两种功能</p><h3 id="初始化阶段" tabindex="-1">初始化阶段： <a class="header-anchor" href="#初始化阶段" aria-label="Permalink to &quot;初始化阶段：&quot;">​</a></h3><ol><li><code>初始化参数</code>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li><code>创建编译器对象</code>：用上一步得到的参数创建 Compiler 对象</li><li><code>初始化编译环境</code>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li><code>开始编译</code>：执行 compiler 对象的 run 方法</li><li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件，调用 compilition.addEntry 将入口文件转换为 dependence 对象</li></ol><h3 id="构建阶段" tabindex="-1">构建阶段 <a class="header-anchor" href="#构建阶段" aria-label="Permalink to &quot;构建阶段&quot;">​</a></h3><ol><li><code>编译模块(make)</code>：根据 entry 对应的 dependence 创建 module 对象，调用 loader 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><code>完成模块编译</code>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的依赖关系图</li></ol><h3 id="生成阶段" tabindex="-1">生成阶段 <a class="header-anchor" href="#生成阶段" aria-label="Permalink to &quot;生成阶段&quot;">​</a></h3><ol><li><code>输出资源(seal)</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><code>写入文件系统(emitAssets)</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol><h2 id="loader-体系" tabindex="-1">loader 体系 <a class="header-anchor" href="#loader-体系" aria-label="Permalink to &quot;loader 体系&quot;">​</a></h2><p>loader 集合读取、转译资源，此前的内容可以千奇百怪， 但转译之后理论上应该输出标准 JavaScript 文本或者 AST 对象，webpack 才能继续处理模块依赖</p><h2 id="plugin-体系" tabindex="-1">plugin 体系 <a class="header-anchor" href="#plugin-体系" aria-label="Permalink to &quot;plugin 体系&quot;">​</a></h2><h3 id="问题-1-什么是插件-插件通常是一个带有-apply-函数的类" tabindex="-1">问题 1:什么是插件：<code>插件通常是一个带有 apply 函数的类</code> <a class="header-anchor" href="#问题-1-什么是插件-插件通常是一个带有-apply-函数的类" aria-label="Permalink to &quot;问题 1:什么是插件：`插件通常是一个带有 apply 函数的类`&quot;">​</a></h3><h3 id="问题-2-什么时间点会有什么钩子被触发" tabindex="-1">问题 2:什么时间点会有什么钩子被触发： <a class="header-anchor" href="#问题-2-什么时间点会有什么钩子被触发" aria-label="Permalink to &quot;问题 2:什么时间点会有什么钩子被触发：&quot;">​</a></h3><ul><li>compiler 对象逐次触发如下钩子</li></ul><table tabindex="0"><thead><tr><th>钩子名称</th><th>描述</th></tr></thead><tbody><tr><td><code>environment</code></td><td>在开始读取 Webpack 配置文件之前触发</td></tr><tr><td><code>afterEnvironment</code></td><td>在读取并解析完 Webpack 配置文件之后触发</td></tr><tr><td><code>entryOption</code></td><td>在处理入口配置项（entry options）之前触发</td></tr><tr><td><code>beforeRun</code></td><td>在运行 compiler 之前触发，所有插件的 <code>apply</code> 方法调用后</td></tr><tr><td><code>run</code></td><td>开始编译主流程，在此阶段会创建 Compilation 对象</td></tr><tr><td><code>watch-run</code> (监听模式)</td><td>当源代码发生变化并重新编译时触发</td></tr><tr><td><code>normal-module-factory</code></td><td>创建 NormalModuleFactory，用于处理模块加载逻辑的插件非常有用</td></tr><tr><td><code>before-compile</code></td><td>在创建 Compilation 对象之前触发</td></tr><tr><td><code>compile</code></td><td>创建 Compilation 对象</td></tr><tr><td><code>make</code> 或 <code>thisCompilation</code></td><td>新 Compilation 对象创建后立即触发，进行资源和模块处理</td></tr><tr><td><code>after-compile</code></td><td>完成一次 Compilation 过程后触发</td></tr><tr><td><code>should-emit</code></td><td>决定是否应该将编译结果写入硬盘</td></tr><tr><td><code>emit</code></td><td>在编译结果准备输出到硬盘前触发，可以修改或替换输出内容</td></tr><tr><td><code>after-emit</code></td><td>在编译结果成功输出到硬盘后触发，常用于清理工作或其他后期处理</td></tr><tr><td><code>done</code></td><td>整个编译过程完成后触发，不论是否有错误发生</td></tr><tr><td><code>failed</code></td><td>如果编译过程中出现错误，则触发此钩子</td></tr></tbody></table><ul><li>compilation 对象逐次触发:</li></ul><table tabindex="0"><thead><tr><th>钩子名称</th><th>描述</th></tr></thead><tbody><tr><td><code>build-module</code></td><td>当一个模块开始构建时触发</td></tr><tr><td><code>normal-module-loader</code></td><td>当使用普通加载器加载模块时触发</td></tr><tr><td><code>module-asset</code></td><td>每当一个模块添加资产到 compilation 时触发</td></tr><tr><td><code>optimize-module-order</code></td><td>优化模块顺序之前触发</td></tr><tr><td><code>optimize-modules-basic</code></td><td>基础模块优化阶段触发</td></tr><tr><td><code>optimize-module-ids</code></td><td>为模块分配唯一标识符（ID）时触发</td></tr><tr><td><code>after-optimize-module-ids</code></td><td>在模块 ID 优化完成后触发</td></tr><tr><td><code>optimize-chunk-ids</code></td><td>为 chunk 分配唯一标识符时触发</td></tr><tr><td><code>after-optimize-chunk-ids</code></td><td>在 chunk ID 优化完成后触发</td></tr><tr><td><code>record-modules</code></td><td>记录所有模块信息前触发</td></tr><tr><td><code>record-chunks</code></td><td>记录所有 chunk 信息前触发</td></tr><tr><td><code>before-hash</code></td><td>在计算 compilation 的 hash 值之前触发</td></tr><tr><td><code>content-hash</code></td><td>当计算内容相关 hash 值时触发</td></tr><tr><td><code>after-hash</code></td><td>在计算完成 compilation 的 hash 值后触发</td></tr><tr><td><code>optimize-chunk-assets</code></td><td>在优化 chunk 资产之前触发</td></tr><tr><td><code>optimize-assets</code></td><td>在优化所有资产之前触发</td></tr><tr><td><code>additional-chunk-assets</code></td><td>在额外的 chunk 资产被加入 compilation 后触发</td></tr><tr><td><code>additional-assets</code></td><td>在其他额外资产被加入 compilation 后触发</td></tr><tr><td><code>need-additional-pass</code></td><td>如果需要再次处理 compilation，则在此触发</td></tr><tr><td><code>before-seal</code></td><td>在 seal（封闭）compilation 过程之前触发</td></tr><tr><td><code>optimize</code></td><td>在执行最终优化步骤前触发</td></tr><tr><td><code>after-optimize</code></td><td>在执行完所有的优化步骤之后触发</td></tr><tr><td><code>seal</code></td><td>在 compilation 封闭（不可再修改）时触发</td></tr><tr><td><code>chunk-graph</code></td><td>当 chunk 图谱可用时触发</td></tr><tr><td><code>after-seal</code></td><td>在 compilation 完全封闭后触发</td></tr><tr><td><code>optimize-tree-chunk</code></td><td>用于 tree shaking 的 chunk 级别优化</td></tr><tr><td><code>optimize-tree-module</code></td><td>用于 tree shaking 的模块级别优化</td></tr><tr><td><code>after-optimizing</code></td><td>在所有优化操作完成后触发</td></tr><tr><td><code>revive-modules</code></td><td>在模块从缓存恢复后触发</td></tr><tr><td><code>optimize-module-factory</code></td><td>优化模块工厂创建过程时触发</td></tr><tr><td><code>optimize-module-factories</code></td><td>在所有模块工厂优化完成后触发</td></tr><tr><td><code>before-module-ids</code></td><td>在给模块分配 id 之前触发</td></tr><tr><td><code>module-id</code></td><td>每个模块 id 被确定时触发</td></tr><tr><td><code>after-module-ids</code></td><td>在所有模块 id 分配完毕后触发</td></tr><tr><td><code>revive-chunks</code></td><td>在 chunks 从缓存恢复后触发</td></tr><tr><td><code>optimize-chunks-basic</code></td><td>基本的 chunk 优化阶段触发</td></tr><tr><td><code>optimize-extracted-chunks</code></td><td>优化提取出的 chunks 时触发</td></tr><tr><td><code>after-optimize-extracted-chunks</code></td><td>在优化提取出的 chunks 完成后触发</td></tr><tr><td><code>optimize-chunk-contents</code></td><td>优化 chunk 内容时触发</td></tr><tr><td><code>before-hash-for-chunk</code></td><td>在计算单个 chunk 的 hash 值之前触发</td></tr><tr><td><code>async</code></td><td>在异步任务完成后触发</td></tr><tr><td><code>child-compiler</code></td><td>子 compiler 创建时触发</td></tr></tbody></table><h3 id="问题-3-如何影响编译状态" tabindex="-1">问题 3:如何影响编译状态 <a class="header-anchor" href="#问题-3-如何影响编译状态" aria-label="Permalink to &quot;问题 3:如何影响编译状态&quot;">​</a></h3><p>webpack 的插件体系与平常所见的 订阅/发布 模式差别很大， 是一种非常强耦合的设计，hooks 回调由 webpack 决定何时，以何种方式执行； 而在 hooks 回调内部可以通过修改状态、调用上下文 api 等方式对 webpack 产生 side effect。</p><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/363928061" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/363928061</a></li><li><a href="https://mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw</a></li></ul>',27),a=[r];function i(l,n,h,p,s,u){return e(),d("div",null,a)}const b=t(c,[["render",i]]);export{k as __pageData,b as default};
