import{_ as l,c as i,o as a,a3 as e}from"./chunks/framework.b23AWjfV.js";const o="/zijieyuan-blog-pages/assets/vdom.DCU5VaAf.jpg",D=JSON.parse('{"title":"虚拟 DOM","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewQuestions/P3 八股文/7.虚拟DOM.md","filePath":"InterviewQuestions/P3 八股文/7.虚拟DOM.md"}'),t={name:"InterviewQuestions/P3 八股文/7.虚拟DOM.md"},r=e('<h1 id="虚拟-dom" tabindex="-1">虚拟 DOM <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 DOM&quot;">​</a></h1><h2 id="虚拟-dom-的工作原理是什么" tabindex="-1">虚拟 DOM 的工作原理是什么？ <a class="header-anchor" href="#虚拟-dom-的工作原理是什么" aria-label="Permalink to &quot;虚拟 DOM 的工作原理是什么？&quot;">​</a></h2><ul><li>讲概念：通过 JS 对象模拟 DOM 节点，</li><li>说用途：在 FaceBook 初期考虑提高代码抽象能力，避免人为的操作 dom，降低代码风险的因素所以引入了虚拟 DOM</li><li>理思路：通过工具转换成，需要的 DOM 树</li><li>列优缺点：</li><li>核心问题：</li></ul><h2 id="虚拟-dom-初衷" tabindex="-1">虚拟 DOM 初衷 <a class="header-anchor" href="#虚拟-dom-初衷" aria-label="Permalink to &quot;虚拟 DOM 初衷&quot;">​</a></h2><ul><li>FaceBook 创建 XHP 项目，</li></ul><ol><li>简化前端开发：为了后端赋能，让后端开发人员能够快速交付页面</li><li>避免跨站点的脚本攻击：</li></ol><p>总结：通过虚拟 DOM 规避风险</p><h2 id="虚拟-dom-关键函数" tabindex="-1">虚拟 DOM 关键函数 <a class="header-anchor" href="#虚拟-dom-关键函数" aria-label="Permalink to &quot;虚拟 DOM 关键函数&quot;">​</a></h2><ul><li>diff 函数： 计算状态变更前后的虚拟 DOM 树的差异</li><li>render 函数：渲染整个虚拟 DOM 树或者处理差异点</li></ul><h2 id="虚拟-dom-优劣势" tabindex="-1">虚拟 DOM 优劣势 <a class="header-anchor" href="#虚拟-dom-优劣势" aria-label="Permalink to &quot;虚拟 DOM 优劣势&quot;">​</a></h2><ul><li><p>优势：</p><ol><li>大量的直接操作 DOM 容易引起网络性能下降。虚拟 Dom 可以降低 DOM 的操作范围和频次，提升页面性能</li><li>跨平台的成本更低</li></ol></li><li><p>劣势：</p><ol><li>内存占用较高</li><li>无法做到极致优化</li></ol></li></ul><h2 id="diff-算法" tabindex="-1">Diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;Diff 算法&quot;">​</a></h2><ul><li>讲概念：</li><li>说用途：</li><li>理思路：</li><li>列优缺点：</li><li>核心问题：</li></ul><h2 id="diff-算法优化策略" tabindex="-1">Diff 算法优化策略 <a class="header-anchor" href="#diff-算法优化策略" aria-label="Permalink to &quot;Diff 算法优化策略&quot;">​</a></h2><ol><li>忽略节点的层级操作场景，提升比对效率 <ul><li>需要进行树对比，即对树进行分层比较，两棵树只对同一层次节点进行比较，如果发现节点已不存在则该节点及其子节点会被完全删除，不会用于进一步比较，提升比较效率</li></ul></li><li>如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构 <ul><li>如果组件是同一类型则进行树比对，如果不是则直接放入补丁中</li></ul></li><li>同一层级子节点，可以通过标记 Key 的方式进行列表对比</li></ol><p><img src="'+o+'" alt="vdom"></p>',16),d=[r];function s(n,h,c,u,f,_){return a(),i("div",null,d)}const O=l(t,[["render",s]]);export{D as __pageData,O as default};
